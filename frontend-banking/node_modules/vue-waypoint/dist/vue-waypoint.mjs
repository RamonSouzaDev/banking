import { ref as s, defineComponent as m, computed as p, watch as d, onMounted as w, onBeforeUnmount as C, h as O } from "vue";
var y = /* @__PURE__ */ ((e) => (e.In = "IN", e.Out = "OUT", e))(y || {}), I = /* @__PURE__ */ ((e) => (e.Up = "UP", e.Down = "DOWN", e.Left = "LEFT", e.Right = "RIGHT", e))(I || {});
const T = (e) => e ? "IN" : "OUT", U = (e, n) => {
  if (e.top < n.top)
    return "UP";
  if (e.left > n.left)
    return "RIGHT";
  if (e.top > n.top)
    return "DOWN";
  if (e.left < n.left)
    return "LEFT";
}, H = (e) => (n) => {
  const o = s();
  return new window.IntersectionObserver(([t]) => {
    var u;
    if (typeof t > "u") {
      console.error("[vue-waypoint]", "observed element is undefined");
      return;
    }
    (u = o.value) != null || (o.value = t.boundingClientRect), n({
      el: t.target,
      going: T(t.isIntersecting),
      direction: U(
        t.boundingClientRect,
        o.value
      )
    }), o.value = t.boundingClientRect;
  }, e);
}, W = m({
  name: "Waypoint",
  props: {
    active: {
      type: Boolean,
      default: () => !0
    },
    options: {
      type: Object,
      default: () => ({})
    },
    tag: {
      type: String,
      default: () => "div"
    },
    disableCssHelpers: {
      type: Boolean,
      default: () => !1
    }
  },
  setup(e, n) {
    const o = s(!1), t = s(null), u = p(
      () => o.value && e.active && t.value !== null
    ), r = s(), g = (a) => r.value = a, i = s();
    d(u, () => {
      var a;
      if (t.value !== null)
        return u.value && i.value ? i.value.observe(t.value) : (a = i.value) == null ? void 0 : a.unobserve(t.value);
    }), d(r, () => {
      typeof r.value > "u" || n.emit("change", r.value);
    }), w(() => {
      o.value = !0, i.value = H(e.options)(g);
    }), C(() => o.value = !1);
    const b = p(() => {
      var c;
      const { going: a, direction: l } = (c = r.value) != null ? c : {}, v = a && `going-${a.toLowerCase()}`, f = l && `direction-${l.toLowerCase()}`;
      return ["waypoint", v, f];
    });
    return () => {
      var l, v, f;
      const a = e.disableCssHelpers ? { ref: t } : { ref: t, class: b.value };
      return O(
        e.tag,
        a,
        (f = (v = n.slots).default) == null ? void 0 : f.call(v, (l = r.value) != null ? l : {})
      );
    };
  }
});
export {
  I as Direction,
  y as Going,
  W as Waypoint
};
